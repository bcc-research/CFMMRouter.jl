<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CFMMRouter.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://bcc-research.github.io/CFMMRouter.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CFMMRouter.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Why-do-we-need-routing?"><span>Why do we need routing?</span></a></li><li><a class="tocitem" href="#Technical-overview"><span>Technical overview</span></a></li><li><a class="tocitem" href="#Optimization-approach"><span>Optimization approach</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="method/">Solution method</a></li><li><a class="tocitem" href="objective/">Specifying objectives</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/Univ3/">Uniswap V3 Router</a></li><li><a class="tocitem" href="examples/arbitrage/">Arbitrage</a></li><li><a class="tocitem" href="examples/liquidate/">Liquidating a basket of tokens</a></li></ul></li><li><a class="tocitem" href="api/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bcc-research/CFMMRouter.jl/blob/main/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CFMM-Router"><a class="docs-heading-anchor" href="#CFMM-Router">CFMM Router</a><a id="CFMM-Router-1"></a><a class="docs-heading-anchor-permalink" href="#CFMM-Router" title="Permalink"></a></h1><p>Convex optimization for fun and profit. (Now in Julia!)</p><h3 id="Documentation-Contents:"><a class="docs-heading-anchor" href="#Documentation-Contents:">Documentation Contents:</a><a id="Documentation-Contents:-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-Contents:" title="Permalink"></a></h3><ul><li><a href="#CFMM-Router">CFMM Router</a></li><li><a href="method/#Solution-method">Solution method</a></li><li><a href="objective/#Objectives">Objectives</a></li></ul><h5 id="Examples:"><a class="docs-heading-anchor" href="#Examples:">Examples:</a><a id="Examples:-1"></a><a class="docs-heading-anchor-permalink" href="#Examples:" title="Permalink"></a></h5><ul><li><a href="examples/arbitrage/#Arbitrage">Arbitrage</a></li><li><a href="examples/liquidate/#Liquidating-a-basket-of-tokens">Liquidating a basket of tokens</a></li></ul><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p><code>CFMMRouting.jl</code> provides a fast, efficient solver for solving routing problems across decentralized exchanges that are implemented as <a href="https://web.stanford.edu/~guillean/papers/cfmm-chapter.pdf"><em>constant function market makers</em></a> (CFMMs, for short) such as Uniswap, Balancer, or Curve.</p><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>To get a quick start, we recommend jumping over to one of the examples, such as: <a href="examples/liquidate/#Liquidating-a-basket-of-tokens">Liquidating a basket of tokens</a>.</p><h2 id="Why-do-we-need-routing?"><a class="docs-heading-anchor" href="#Why-do-we-need-routing?">Why do we need routing?</a><a id="Why-do-we-need-routing?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-do-we-need-routing?" title="Permalink"></a></h2><p>In general, decentralized exchanges, such as Uniswap, Balancer, Curve, among many others, are organized as CFMMs—a particular type of automated market maker, whose behavior is mathematically defined by a <em>trading function</em>. A trader can then use a CFMM to trade a basket of assets (sometimes known as tokens) for another desired basket of assets, so long as the desired trade satisfies some conditions.</p><p>While there may be many assets in a network, in practice, individual CFMMs trade only a small number of these assets. This fact leads to several interesting problems when trading.</p><p>In one simple scenario, a trader might want to trade some amount <span>$x$</span> of token A for token B. It is then reasonable to ask: what is the largest amount of token B that can be received given this amount <span>$x$</span> of token A? If the trader is only allowed to trade with a single market of their choosing, the solution to this problem is easy—the trader simply checks how much of token B, given quantity <span>$x$</span> of token A, they expect to receive from each market that trades tokens A and B, and picks the market that gives the maximum amount of token B. When they are allowed to trade against any number of markets, as is usually the case in decentralized finance, the problem becomes substantially more complicated.  In this case, an optimal solution could involve not only splitting an order across numerous individual markets trading tokens A and B, but also including sequential trades across any combination of markets which include other tokens. Finding the best way to execute this order is known as the <a href="https://angeris.github.io/papers/cfmm-routing.pdf"><em>optimal routing problem</em></a>.</p><p>The main idea behind this package is to note that the problem of optimal routing can often be phrased as a <a href="https://www.stanford.edu/~boyd/cvxbook/">convex optimization problem</a>. Problems of this form can generally be quickly and robustly solved in practice, even for relatively large problem instances. This package also exploits some additional structure present in the optimal routing problem to further speed up problem solving. More details about this approach can be found in the sections below.</p><p>While the solution method is somewhat technical, using this package requires very little optimization knowledge. We highly recommend starting with the examples provided!</p><h2 id="Technical-overview"><a class="docs-heading-anchor" href="#Technical-overview">Technical overview</a><a id="Technical-overview-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-overview" title="Permalink"></a></h2><p>This package provides a high performance implementation of the optimal multi-exchange routing problem  from <a href="https://web.stanford.edu/~guillean/papers/cfmm-routing.pdf">Optimal routing for constant function market makers</a><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>:</p><p class="math-container">\[\begin{array}{ll}
\text{maximize}     &amp; U(\Psi) \\
\text{subject to}   &amp; \Psi = \sum_{i=1}^m A_i(\Lambda_i - \Delta_i) \\
&amp; \phi_i(R_i + \gamma_i\Delta_i - \Lambda_i) = \phi_i(R_i), \quad i = 1, \dots, m \\
&amp;\Delta_i \geq 0, \quad \Lambda_i \geq 0, \quad i = 1, \dots, m.
\end{array}\]</p><p>A routing problem is specified by the list of CFMMs that the trader can interact with and a concave, increasing utility function <span>$U: \mathbf{R}^n \to \mathbf{R}$</span>, depending only on the <em>net output</em> of all trades (we will define what this means momentarily).</p><p>Each CFMM is associated with a subset of <span>$n_i$</span> tokens which we will write as some subset <span>$S_i \subseteq \{1, \dots, n\}$</span>. Every CFMM <span>$i$</span> has some trading function <span>$\phi_i: \mathbf{R}^{n_i} \to \mathbf{R} \cup \{\infty\}$</span>, reserves <span>$R_i \in \mathbf{R}^{n_i}$</span>, fee <span>$0 &lt; \gamma_i \le 1$</span>, and matrix <span>$A_i \in \mathbf{R}^{n \times n_i}$</span>, mapping the local token basket that the CFMM trades to the network&#39;s token basket. We solve for the tendered baskets <span>$\Delta_i \in \mathbf{R}^{n_i}_+$</span>, the received baskets <span>$\Lambda_i \in \mathbf{R}^{n_i}_+$</span> for each CFMM <span>$i$</span>, which results in the network trade vector <span>$\Psi \in \mathbf{R}^n$</span> that maximizes the function <span>$U$</span>. For more information on this problem, we recommend reading the original paper<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><h4 id="Uses"><a class="docs-heading-anchor" href="#Uses">Uses</a><a id="Uses-1"></a><a class="docs-heading-anchor-permalink" href="#Uses" title="Permalink"></a></h4><p>The routing problem includes a large number of tasks that users might be interested in, including, for example</p><ul><li>Liquidating a basket of tokens</li><li>Trading token A for token B</li><li>Finding arbitrage opportunities</li><li>And more...</li></ul><h4 id="Solutions-and-net-trades"><a class="docs-heading-anchor" href="#Solutions-and-net-trades">Solutions and net trades</a><a id="Solutions-and-net-trades-1"></a><a class="docs-heading-anchor-permalink" href="#Solutions-and-net-trades" title="Permalink"></a></h4><p>A <em>solution</em> for this problem is provided as an (unordered) set of trades <span>$(\Delta_i, \Lambda_i)$</span> to be performed with each CFMM <span>$i$</span>.</p><p>If <em>all</em> trades provided by the solution were to be executed, some tokens might have negative balances (<em>i.e.</em>, the user needs to tender these tokens for the transaction to succeed) or positive balances (<em>i.e.</em>, the user will instead <em>receive</em> this amount of tokens, assuming the trades all succeed). The resulting amounts of each token to be tendered or received, after all trades are netted out, is called the <em>network trade vector</em>, which we have denoted <span>$\Psi$</span> above.</p><h4 id="Executing-solutions"><a class="docs-heading-anchor" href="#Executing-solutions">Executing solutions</a><a id="Executing-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-solutions" title="Permalink"></a></h4><p>The solution this package provides are a set of trades that, when netted out, maximizes the utility function <span>$U$</span>.  With a small amount of additional effort, it is possible to convert this unordered set of trades into a list of trades that can be included in a transaction. We will cover some approaches for how to convert a set of trades into a reasonable transaction in a future post.</p><h2 id="Optimization-approach"><a class="docs-heading-anchor" href="#Optimization-approach">Optimization approach</a><a id="Optimization-approach-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-approach" title="Permalink"></a></h2><p>To solve the optimal routing problem presented here, this package uses a common technique in large scale optimization: we decompose the problem such that the optimal trade on each individual CFMM can be solved independently. It is easy to see that the only constraint coupling the CFMM trades together is</p><p class="math-container">\[\Psi = \sum_{i=1}^m A_i(\Lambda_i - \Delta_i).\]</p><p>Therefore, if we can eliminate this constraint, the subproblems can be solved in a fully parallelizable way. Intuitively, our approach is to relax this constraint to be a penalty in the objective, where there is some cost of violation. If we fix these costs at a given round, the CFMM subproblems can be solved independently. We then use these subproblem solutions to update the cost of violation and iterate this process. The algorithmic details are explained in the <a href="method/#Solution-method">Solution method</a> section.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>G. Angeris, T. Chitra, A. Evans, and S. Boyd. <a href="https://angeris.github.io/papers/cfmm-routing.pdf">Optimal routing for constant function market makers</a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="method/">Solution method »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 19 October 2022 17:35">Wednesday 19 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
