var documenterSearchIndex = {"docs":
[{"location":"examples/arbitrage/","page":"Arbitrage","title":"Arbitrage","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/arbitrage/","page":"Arbitrage","title":"Arbitrage","text":"EditURL = \"https://github.com/bcc-research/CFMMRouter.jl/blob/main/examples/arbitrage.jl\"","category":"page"},{"location":"examples/arbitrage/#Arbitrage","page":"Arbitrage","title":"Arbitrage","text":"","category":"section"},{"location":"examples/arbitrage/","page":"Arbitrage","title":"Arbitrage","text":"This example illustrates how to use CFMMRouter.jl to solve the multi-market arbitrage problem","category":"page"},{"location":"examples/arbitrage/","page":"Arbitrage","title":"Arbitrage","text":"using CFMMRouter\nusing LinearAlgebra\n\n# Create three pools of the same tokens, no fees (γ=1)\nequal_pool = ProductTwoCoin([1e6, 1e6], 1, [1, 2])\nunequal_small_pool = ProductTwoCoin([1e3, 2e3], 1, [1, 2])\nweighted_pool = GeometricMeanTwoCoin([1e4, 2e4], [.4, .6], 1, [1, 2])\n\n# Build a routing problem with price vector = [1.0, 1.0]\nprices = ones(2)\nrouter = Router(\n    LinearNonnegative(prices),\n    [equal_pool, unequal_small_pool, weighted_pool],\n    2,\n)\n\n# Optimize!\nroute!(router)\n\n# Print results\nΨ = round.(Int, netflows(router))\nprintln(\"Net trade: $Ψ\")\nprintln(\"Profit: $(dot(prices, Ψ))\")","category":"page"},{"location":"examples/arbitrage/","page":"Arbitrage","title":"Arbitrage","text":"We can also see the list of individual trades with each CFMM:","category":"page"},{"location":"examples/arbitrage/","page":"Arbitrage","title":"Arbitrage","text":"# Print individual trades\nfor (i, (Δ, Λ)) in enumerate(zip(router.Δs, router.Λs))\n    tokens = router.cfmms[i].Ai\n    println(\"CFMM $i:\")\n    println(\"\\tTendered basket:\")\n    for (ind, δ) in enumerate(Δ)\n        if δ > eps()\n            print(\"\\t  $(tokens[ind]): $(round(Int, δ)), \")\n        end\n    end\n    println(\"\\n\\tRecieved basket:\")\n    for (ind, λ) in enumerate(Λ)\n        if λ > eps()\n            print(\"\\t  $(tokens[ind]): $(round(Int, λ)), \")\n        end\n    end\n    print(\"\\n\")\nend","category":"page"},{"location":"examples/arbitrage/","page":"Arbitrage","title":"Arbitrage","text":"","category":"page"},{"location":"examples/arbitrage/","page":"Arbitrage","title":"Arbitrage","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [CFMMRouter]","category":"page"},{"location":"api/#CFMMRouter.BasketLiquidation","page":"API reference","title":"CFMMRouter.BasketLiquidation","text":"BasketLiquidation(i, Δin)\n\nLiquidation objective for the routing problem,\n\n    Psi_i - mathbfI(Psi_-i + Δ^mathrmin_-i = 0  Psi_i geq 0)\n\nwhere i is the desired output token and Δin is the basket of tokens to be liquidated.\n\n\n\n\n\n","category":"type"},{"location":"api/#CFMMRouter.GeometricMeanTwoCoin","page":"API reference","title":"CFMMRouter.GeometricMeanTwoCoin","text":"GeometricMeanTwoCoin(R, w, γ, idx)\n\nCreates a two coin geometric mean CFMM with coins idx[1] and idx[2],  reserves R, fee γ, and weights w such that w[1] + w[2] == 1.0. Specifically, the invariant is\n\nvarphi(R) = R_1^w_1R_2^w_2\n\n\n\n\n\n","category":"type"},{"location":"api/#CFMMRouter.LinearNonnegative","page":"API reference","title":"CFMMRouter.LinearNonnegative","text":"LinearNonnegative(c)\n\nLinear objective for the routing problem,\n\n    U(Psi) = c^TPsi - mathbfI(Psi geq 0)\n\nwhere c is a positive price vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#CFMMRouter.ProductTwoCoin","page":"API reference","title":"CFMMRouter.ProductTwoCoin","text":"ProductTwoCoin(R, γ, idx)\n\nCreates a two coin product CFMM with coins idx[1] and idx[2], reserves R, and fee γ. Specifically, the invariant is\n\nvarphi(R) = R_1R_2\n\n\n\n\n\n","category":"type"},{"location":"api/#CFMMRouter.Router-Union{Tuple{C}, Tuple{O}, Tuple{T}, Tuple{O, Vector{C}, Any}} where {T, O<:Objective, C<:CFMM{T}}","page":"API reference","title":"CFMMRouter.Router","text":"Router(objective, cfmms, n_tokens)\n\nConstructs a router that finds a set of trades (router.Δs, router.Λs) through cfmms  which maximizes objective. The number of tokens n_tokens must be specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#CFMMRouter.Swap-Union{Tuple{T}, Tuple{Int64, Int64, T, Int64}} where T<:AbstractFloat","page":"API reference","title":"CFMMRouter.Swap","text":"Swap(i, j, δ, n)\n\nSwap objective for the routing problem with n tokens:\n\n    Psi_i - mathbfI(Psi_nsetminusij = 0 Psi_j = -delta)\n\nwhere i is the desired output token, j is the input token, and δ the amount input. Note that this is shorthand for a BasketLiquidation objective where Δin is a one-hot vector. \n\n\n\n\n\n","category":"method"},{"location":"api/#CFMMRouter.f","page":"API reference","title":"CFMMRouter.f","text":"f(obj::Objective, v)\n\nEvaluates the conjugate of the utility function of objective at v. Specifically,\n\n    f(nu) = sup_Psi left(U(Psi) - nu^T Psi right)\n\n\n\n\n\n","category":"function"},{"location":"api/#CFMMRouter.find_arb!","page":"API reference","title":"CFMMRouter.find_arb!","text":"find_arb!(Δ, Λ, cfmm, v)\n\nSolves the arbitrage problem for cfmm given price vector v,\n\nbeginarrayll\ntextminimize  nu^T(Lambda - Delta) \ntextsubject to  varphi(R + gammaDelta - Lambda) = varphi(R) \n Delta Lambda geq 0\nendarray\n\nOverwrites the variables Δ and Λ.\n\n\n\n\n\n","category":"function"},{"location":"api/#CFMMRouter.grad!","page":"API reference","title":"CFMMRouter.grad!","text":"grad!(g, obj::Objective, v)\n\nComputes the gradient of f(obj, v) at v.\n\n\n\n\n\n","category":"function"},{"location":"api/#CFMMRouter.lower_limit","page":"API reference","title":"CFMMRouter.lower_limit","text":"lower_limit(obj)\n\nComponentwise lower bound on argument v for objective f.   Returns a vector with length length(v) (number of tokens).\n\n\n\n\n\n","category":"function"},{"location":"api/#CFMMRouter.route!-Tuple{R} where R<:Router","page":"API reference","title":"CFMMRouter.route!","text":"route!(r::Router)\n\nSolves the routing problem,\n\nbeginarrayll\ntextmaximize      U(Psi) \ntextsubject to    Psi = sum_i=1^m A_i(Lambda_i - Delta_i) \n phi_i(R_i + gamma_iDelta_i - Lambda_i) geq phi_i(R_i) quad i = 1 dots m \nDelta_i geq 0 quad Lambda_i geq 0 quad i = 1 dots m\nendarray\n\nOverwrites r.Δs and r.Λs.\n\n\n\n\n\n","category":"method"},{"location":"api/#CFMMRouter.upper_limit","page":"API reference","title":"CFMMRouter.upper_limit","text":"upper_limit(obj)\n\nComponentwise upper bound on argument v for objective f.   Returns a vector with length length(v) (number of tokens).\n\n\n\n\n\n","category":"function"},{"location":"api/#CFMMRouter.ϕ","page":"API reference","title":"CFMMRouter.ϕ","text":"ϕ(c::CFMM)\n\nComputes the trading function for CFMM c.\n\n\n\n\n\n","category":"function"},{"location":"api/#CFMMRouter.∇ϕ!","page":"API reference","title":"CFMMRouter.∇ϕ!","text":"∇ϕ!(x, c::CFMM)\n\nComputes the gradient of the trading function for CFMM c. The result is stored in x.\n\n\n\n\n\n","category":"function"},{"location":"examples/liquidate/","page":"Liquidating a basket of tokens","title":"Liquidating a basket of tokens","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/liquidate/","page":"Liquidating a basket of tokens","title":"Liquidating a basket of tokens","text":"EditURL = \"https://github.com/bcc-research/CFMMRouter.jl/blob/main/examples/liquidate.jl\"","category":"page"},{"location":"examples/liquidate/#Liquidating-a-basket-of-tokens","page":"Liquidating a basket of tokens","title":"Liquidating a basket of tokens","text":"","category":"section"},{"location":"examples/liquidate/","page":"Liquidating a basket of tokens","title":"Liquidating a basket of tokens","text":"This example illustrates how to use CFMMRouter.jl to liquidate a basket of tokens.","category":"page"},{"location":"examples/liquidate/","page":"Liquidating a basket of tokens","title":"Liquidating a basket of tokens","text":"using CFMMRouter\nusing LinearAlgebra\n\n# Create CFMMs\ncfmms = [\n    ProductTwoCoin([1e3, 1e4], 0.997, [1, 2]),\n    ProductTwoCoin([1e3, 1e2], 0.997, [2, 3]),\n    ProductTwoCoin([1e3, 2e4], 0.997, [1, 3])\n]\n\n# We want to liquidate a basket of tokens 2 & 3 into token 1\nΔin = [0, 1e1, 1e2]\n\n# Build a routing problem with liquidation objective\nrouter = Router(\n    BasketLiquidation(1, Δin),\n    cfmms,\n    maximum([maximum(cfmm.Ai) for cfmm in cfmms]),\n)\n\n# Optimize!\nroute!(router)\n\n# Print results\nΨ = round.(Int, netflows(router))\nprintln(\"Input Basket: $(round.(Int, Δin))\")\nprintln(\"Net trade: $Ψ\")\nprintln(\"Amount recieved: $(Ψ[1])\")","category":"page"},{"location":"examples/liquidate/","page":"Liquidating a basket of tokens","title":"Liquidating a basket of tokens","text":"We can also see the list of individual trades with each CFMM:","category":"page"},{"location":"examples/liquidate/","page":"Liquidating a basket of tokens","title":"Liquidating a basket of tokens","text":"# Print individual trades\nfor (i, (Δ, Λ)) in enumerate(zip(router.Δs, router.Λs))\n    tokens = router.cfmms[i].Ai\n    println(\"CFMM $i:\")\n    println(\"\\tTendered basket:\")\n    for (ind, δ) in enumerate(Δ)\n        if δ > eps()\n            print(\"\\t  $(tokens[ind]): $(round(Int, δ)), \")\n        end\n    end\n    println(\"\\n\\tRecieved basket:\")\n    for (ind, λ) in enumerate(Λ)\n        if λ > eps()\n            print(\"\\t  $(tokens[ind]): $(round(Int, λ)), \")\n        end\n    end\n    print(\"\\n\")\nend","category":"page"},{"location":"examples/liquidate/#Special-Case:-Trade-Token-1-Token-2","page":"Liquidating a basket of tokens","title":"Special Case: Trade Token 1 -> Token 2","text":"","category":"section"},{"location":"examples/liquidate/","page":"Liquidating a basket of tokens","title":"Liquidating a basket of tokens","text":"Δin = [1e1, 0.0, 0.0]\n\n# Build a routing problem with liquidation objective (output to token 2)\nrouter = Router(\n    BasketLiquidation(2, Δin),\n    cfmms,\n    maximum([maximum(cfmm.Ai) for cfmm in cfmms]),\n)\n\n# Optimize!\nroute!(router)\n\n# Print results\nΨ = round.(Int, netflows(router))\nprintln(\"Input Basket: $(round.(Int, Δin))\")\nprintln(\"Net trade: $Ψ\")\nprintln(\"Amount recieved: $(Ψ[1])\")","category":"page"},{"location":"examples/liquidate/","page":"Liquidating a basket of tokens","title":"Liquidating a basket of tokens","text":"List of individual trades with each CFMM:","category":"page"},{"location":"examples/liquidate/","page":"Liquidating a basket of tokens","title":"Liquidating a basket of tokens","text":"# Print individual trades\nfor (i, (Δ, Λ)) in enumerate(zip(router.Δs, router.Λs))\n    tokens = router.cfmms[i].Ai\n    println(\"CFMM $i:\")\n    println(\"\\tTendered basket:\")\n    for (ind, δ) in enumerate(Δ)\n        if δ > eps()\n            print(\"\\t  $(tokens[ind]): $(round(Int, δ)), \")\n        end\n    end\n    println(\"\\n\\tRecieved basket:\")\n    for (ind, λ) in enumerate(Λ)\n        if λ > eps()\n            print(\"\\t  $(tokens[ind]): $(round(Int, λ)), \")\n        end\n    end\n    print(\"\\n\")\nend","category":"page"},{"location":"examples/liquidate/","page":"Liquidating a basket of tokens","title":"Liquidating a basket of tokens","text":"","category":"page"},{"location":"examples/liquidate/","page":"Liquidating a basket of tokens","title":"Liquidating a basket of tokens","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Univ3/","page":"-","title":"-","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/Univ3/","page":"-","title":"-","text":"EditURL = \"https://github.com/bcc-research/CFMMRouter.jl/blob/main/examples/Univ3.jl\"","category":"page"},{"location":"examples/Univ3/","page":"-","title":"-","text":"using CFMMRouter\nusing LinearAlgebra, SparseArrays, StaticArrays\n\n\n#The price in each tick refers to the lower bound on the interval\n#so the intervals are [t_i,t_i+1] with liquidity L_i","category":"page"},{"location":"examples/Univ3/","page":"-","title":"-","text":"    p2---------","category":"page"},{"location":"examples/Univ3/","page":"-","title":"-","text":"p1–––     |     p3–––-   |          |         |   L1         L2        L3   |          |         |","category":"page"},{"location":"examples/Univ3/","page":"-","title":"-","text":"tick_list = [Dict(\"price\" => .1, \"liquidity\" => 1.0),\n             Dict(\"price\" => .5, \"liquidity\" => 1.0),\n             Dict(\"price\" => 1.0, \"liquidity\" => 100.0),\n             Dict(\"price\" => 2.0, \"liquidity\" => 1.0),\n             Dict(\"price\" => 4.0, \"liquidity\" => 1.0)]\n\npool = UniV3([100,100],1,[1,2],1.0,3,tick_list)\nΔ = [0.0,0.0]\nΛ = [0.0,0.0]\n\nfind_arb!(Δ,Λ,pool, [1.0,2.0])\n\nprint(Δ,Λ)\n\nupdate_reserves!(pool, Δ, Λ, [1.0,2.0])\n\nprint(pool.current_price, pool.current_tick_index)","category":"page"},{"location":"examples/Univ3/","page":"-","title":"-","text":"","category":"page"},{"location":"examples/Univ3/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"method/#Solution-method","page":"Solution method","title":"Solution method","text":"","category":"section"},{"location":"method/","page":"Solution method","title":"Solution method","text":"Here we describe our algorithmic approach to solve the routing problem","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"beginarrayll\ntextmaximize      U(Psi) \ntextsubject to    Psi = sum_i=1^m A_i(Lambda_i - Delta_i) \n phi_i(R_i + gamma_iDelta_i - Lambda_i) = phi_i(R_i) quad i = 1 dots m \nDelta_i geq 0 quad Lambda_i geq 0 quad i = 1 dots m\nendarray","category":"page"},{"location":"method/#Overview","page":"Solution method","title":"Overview","text":"","category":"section"},{"location":"method/","page":"Solution method","title":"Solution method","text":"Our approach is a common one in large scale optimization: we decompose the problem such that the optimal trade on each individual CFMM can be solved independently. It is easy to see that the only constraint coupling the CFMM trades together is","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"Psi = sum_i=1^m A_i(Lambda_i - Delta_i)","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"Therefore, if we can eliminate this constraint, the subproblems can be solved independently. Intuitively, our approach is to relax this constraint to be a penalty in the objective, where there is some cost of violation. If we fix these costs at a given round, the CFMM subproblems can be solved independently. We then use these subproblem solutions to update the cost of violation and iterate this process. The algorithmic details are explained below.","category":"page"},{"location":"method/#Partial-dualization-of-the-constraints","page":"Solution method","title":"Partial dualization of the constraints","text":"","category":"section"},{"location":"method/","page":"Solution method","title":"Solution method","text":"Motivated by the insight above, we form the (partial) Lagrangian","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"mathcalL(Psi Delta Lambda nu) = U(Psi) -\nnu^T(Psi - sum_i=1^m A_i(Lambda_i - Delta_i)) -\nsum_i=1^m mathbfI_i(Delta_i Lambda_i)","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"where nu is a dual variable and ","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"mathbfI_i(Delta_i Lambda_i) =\nbegincases\n0  Delta_i Lambda_i geq 0 text and  phi_i(R_i + gamma_iDelta_i - Lambda_i) geq phi(R_i) \ninfty  textotherwise\nendcases","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"In other words I_i is an indicator function which is 0 if the trade (Delta_i Lambda_i) satisfies the CFMM's constraints and is positive infinity otherwise.","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"Notice that we only introduce a dual variable for the coupling constraint. The corresponding dual function, found by minimization over the primal variables, is","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"beginaligned\ng(nu) = sup_Psi Delta_i Lambda_i mathcalL(Psi Delta Lambda nu) \n= sup_Psi left(U(Psi) -\nnu^TPsiright) + sum_i=1^m sup_Delta_i Lambda_ileft(\n(A_i^Tnu)^T(Lambda_i - Delta_i) -mathbfI_i(Delta_i Lambda_i) right) \n= (-U)^*(-nu) + sum_i=1^m mathbfarb_i(A^Tnu)\nendaligned","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"where mathbfarb_i(A^Tnu) is the optimal arbitrage profit from CFMM i with external \"market prices\" A^Tnu and (-U)^* is the Fenchel conjugate of -U. The optimal arbitrage problem for each CFMM i can be solved in parallel as the problems are fully independent. This problem corresponds to the following convex optimization problem:","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"beginarrayll\ntextmaximize  (A_i^Tnu)^T(Lambda_i - Delta_i)\ntextsubject to  phi_i(R_i + gamma_iDelta_i - Lambda_i) geq phi_i(R_i) \nDelta_i geq 0 quad Lambda_i geq 0\nendarray","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"The general arbitrage problem, for arbitrary, convex trading functions phi, can be efficiently solved with standard techniques (e.g., a primal-dual interior point method). On the other hand, for many common CFMMs (e.g., Uniswap v2) this problem has a closed form solution (c.f., Appendix A[2]) which we exploit in our solver.","category":"page"},{"location":"method/#Minimizing-the-dual-problem","page":"Solution method","title":"Minimizing the dual problem","text":"","category":"section"},{"location":"method/","page":"Solution method","title":"Solution method","text":"As a result of strong duality, minimizing g(nu) is equivalent to solving the original problem in that the optimal values are equal. After optimizing g(nu), we can reconstruct the trade using the Delta_i's and Lambda_i's found in the sub problems.","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"To minimize g(nu), we use L-BFGS-B[3], which requires evaluation of g(nu) and nabla g(nu). Note that the gradient of the Fenchel conjugate nabla f^*(y) is the x at which the supremum sup_x (y^Tx - f(x)) is attained (this may not be a unique point but instead be a set of points—called the subdifferential—in which case we simply choose any x in this set).","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"The gradient nabla_nu mathbfarb_i(A_i^Tnu) = A_i (Lambda_i^* - Delta_i^*), where Lambda^* and Delta_i^* are the optimal values associated with mathbfarb_i(A_i^Tnu). Thus,","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"beginaligned\nnabla g(nu) = -Psi^* + sum_i=1^m A_i (Lambda_i^* - Delta_i^*)\nendaligned","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"By evaluating the function g(nu), we get the gradient essentially for free. ","category":"page"},{"location":"method/#Extensions-and-notes","page":"Solution method","title":"Extensions and notes","text":"","category":"section"},{"location":"method/","page":"Solution method","title":"Solution method","text":"In the near future, we will support user-created CFMMs as well, which are specified by the trading function phi, its gradient nabla phi, and its Hessian nabla^2phi. The gradient and Hessian may be specified exactly or by using automatic differentiation tools such as ForwardDiff.jl [4]. This method could be extended to include gas fees and uncertain transaction execution (probabalistic constraints).","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"When using this method with real-world data, numerical issues (caused by the magnitude of and order of magnitude differences between numbers) may need to be carefully addressed via appropriate scaling. Additionally, the dual decomposition technique used will not necessarily yield a feasible Psi when the trading function phi is not strictly concave [5] (e.g., for a constant sum CFMM). In this case, extra care needs to be taken during implementation.","category":"page"},{"location":"method/#References","page":"Solution method","title":"References","text":"","category":"section"},{"location":"method/","page":"Solution method","title":"Solution method","text":"[1]: G. Angeris, T. Chitra, A. Evans, S. Boyd (2021). Optimal routing for constant function market makers.","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"[2]: G. Angeris, H. T. Kao, R. Chiang, C. Noyes, T. Chitra (2019). An analysis of Uniswap markets.","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"[3]: C. Zhu, H. R. Byrd, P. Lu, J. Nocedal (1997). L-BFGS-B.","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"[4]: J. Revels, M. Lubin, T. Papamarkou (2016). Forward-mode automatic differentiation in Julia.","category":"page"},{"location":"method/","page":"Solution method","title":"Solution method","text":"[5]: S. Boyd, L. Xiao, A. Mutapcic, J. Mattingley (2015). Notes on Decomposition Methods","category":"page"},{"location":"objective/#Objectives","page":"Specifying objectives","title":"Objectives","text":"","category":"section"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"We include a few simple utility functions with this package.  Arbitrary utility functions (which can include constraints) are specified in the  objectives.jl file. We outline the included utility functions and how to specify new ones below.","category":"page"},{"location":"objective/#Included-utility-functions","page":"Specifying objectives","title":"Included utility functions","text":"","category":"section"},{"location":"objective/#LinearNonnegative-(arbitrage)","page":"Specifying objectives","title":"LinearNonnegative (arbitrage)","text":"","category":"section"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"The LinearNonnegative objective is","category":"page"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"    U(Psi) = c^TPsi - mathbfI(Psi geq 0)","category":"page"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"where c is a positive price vector. mathbbI(Psi ge 0) is an indicator function that is 0 if Psi ge 0 and +infty otherwise. This objective requires no net input and a linear utility for each token, defined by the price vector. A nonzero solution to this problem finds an arbitrage in the network—a set of trades that yields strictly positive value, but requires no net input.","category":"page"},{"location":"objective/#BasketLiquidation-(liquidations-and-swaps)","page":"Specifying objectives","title":"BasketLiquidation (liquidations and swaps)","text":"","category":"section"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"The BasketLiquidation objective is ","category":"page"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"    U(Psi) = Psi_i - mathbfI(Psi_-i + Δ^mathrmin_-i = 0  Psi_i geq 0)","category":"page"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"where Δ^mathrmin is a basket of tokens to be liquidated into token i. Here, Psi_-i is the vector Psi with entry i removed, and mathbfI(Psi_-i + Δ^mathrmin_-i = 0 Psi_i geq 0) is the indicator function which is zero if all conditions are met and is infty, otherwise. In the special case where Δ^mathrmin_k is zero at all indices except for some index j ne i, this objective defines a swap from token j to token i where we attempt to maximize the amount of token i received. We implement a Swap objective as shorthand for this special case.","category":"page"},{"location":"objective/#Specifying-new-utility-functions","page":"Specifying objectives","title":"Specifying new utility functions","text":"","category":"section"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"New utility functions can be easily specified following the examples in objectives.jl. We only need to specify the conjugate f(nu) and its gradient:","category":"page"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"    f(nu) = sup_Psi left(U(Psi) - nu^T Psi right)","category":"page"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"and","category":"page"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"nabla f(nu) = -Psi^star","category":"page"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"where Psi^star is the optimal value of the supremum in f(nu). In addition, we specify lower bound lower_limit and upper bound upper_limit for the objective.","category":"page"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"Sometimes f(nu) does not have a closed form solution, so we need to solve an additional optimization problem to evaluate the objective.  For example, consider Markowitz portfolio rebalancing:","category":"page"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"U(Psi) = mu^T(Psi + Delta^mathrmin) - fracgamma2\n(Psi + Delta^mathrmin)^TSigma(Psi + Delta^mathrmin) \n- mathbbI(Psi + Delta^mathrmin geq 0)","category":"page"},{"location":"objective/","page":"Specifying objectives","title":"Specifying objectives","text":"where mu and Sigma are the (estimated) mean and covariance returns for each token.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CFMMRouter","category":"page"},{"location":"#CFMM-Router","page":"Home","title":"CFMM Router","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Convex optimization for fun and profit. (Now in Julia!)","category":"page"},{"location":"#Documentation-Contents:","page":"Home","title":"Documentation Contents:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\", \"method.md\", \"objective.md\"]\nDepth = 1","category":"page"},{"location":"#Examples:","page":"Home","title":"Examples:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"examples/arbitrage.md\", \"examples/liquidate.md\"]\nDepth = 1","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CFMMRouting.jl provides a fast, efficient solver for solving routing problems across decentralized exchanges that are implemented as constant function market makers (CFMMs, for short) such as Uniswap, Balancer, or Curve.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To get a quick start, we recommend jumping over to one of the examples, such as: Liquidating a basket of tokens.","category":"page"},{"location":"#Why-do-we-need-routing?","page":"Home","title":"Why do we need routing?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In general, decentralized exchanges, such as Uniswap, Balancer, Curve, among many others, are organized as CFMMs—a particular type of automated market maker, whose behavior is mathematically defined by a trading function. A trader can then use a CFMM to trade a basket of assets (sometimes known as tokens) for another desired basket of assets, so long as the desired trade satisfies some conditions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While there may be many assets in a network, in practice, individual CFMMs trade only a small number of these assets. This fact leads to several interesting problems when trading.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In one simple scenario, a trader might want to trade some amount x of token A for token B. It is then reasonable to ask: what is the largest amount of token B that can be received given this amount x of token A? If the trader is only allowed to trade with a single market of their choosing, the solution to this problem is easy—the trader simply checks how much of token B, given quantity x of token A, they expect to receive from each market that trades tokens A and B, and picks the market that gives the maximum amount of token B. When they are allowed to trade against any number of markets, as is usually the case in decentralized finance, the problem becomes substantially more complicated.  In this case, an optimal solution could involve not only splitting an order across numerous individual markets trading tokens A and B, but also including sequential trades across any combination of markets which include other tokens. Finding the best way to execute this order is known as the optimal routing problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main idea behind this package is to note that the problem of optimal routing can often be phrased as a convex optimization problem. Problems of this form can generally be quickly and robustly solved in practice, even for relatively large problem instances. This package also exploits some additional structure present in the optimal routing problem to further speed up problem solving. More details about this approach can be found in the sections below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While the solution method is somewhat technical, using this package requires very little optimization knowledge. We highly recommend starting with the examples provided!","category":"page"},{"location":"#Technical-overview","page":"Home","title":"Technical overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a high performance implementation of the optimal multi-exchange routing problem  from Optimal routing for constant function market makers[1]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginarrayll\ntextmaximize      U(Psi) \ntextsubject to    Psi = sum_i=1^m A_i(Lambda_i - Delta_i) \n phi_i(R_i + gamma_iDelta_i - Lambda_i) = phi_i(R_i) quad i = 1 dots m \nDelta_i geq 0 quad Lambda_i geq 0 quad i = 1 dots m\nendarray","category":"page"},{"location":"","page":"Home","title":"Home","text":"A routing problem is specified by the list of CFMMs that the trader can interact with and a concave, increasing utility function U mathbfR^n to mathbfR, depending only on the net output of all trades (we will define what this means momentarily).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each CFMM is associated with a subset of n_i tokens which we will write as some subset S_i subseteq 1 dots n. Every CFMM i has some trading function phi_i mathbfR^n_i to mathbfR cup infty, reserves R_i in mathbfR^n_i, fee 0  gamma_i le 1, and matrix A_i in mathbfR^n times n_i, mapping the local token basket that the CFMM trades to the network's token basket. We solve for the tendered baskets Delta_i in mathbfR^n_i_+, the received baskets Lambda_i in mathbfR^n_i_+ for each CFMM i, which results in the network trade vector Psi in mathbfR^n that maximizes the function U. For more information on this problem, we recommend reading the original paper[1].","category":"page"},{"location":"#Uses","page":"Home","title":"Uses","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The routing problem includes a large number of tasks that users might be interested in, including, for example","category":"page"},{"location":"","page":"Home","title":"Home","text":"Liquidating a basket of tokens\nTrading token A for token B\nFinding arbitrage opportunities\nAnd more...","category":"page"},{"location":"#Solutions-and-net-trades","page":"Home","title":"Solutions and net trades","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A solution for this problem is provided as an (unordered) set of trades (Delta_i Lambda_i) to be performed with each CFMM i.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If all trades provided by the solution were to be executed, some tokens might have negative balances (i.e., the user needs to tender these tokens for the transaction to succeed) or positive balances (i.e., the user will instead receive this amount of tokens, assuming the trades all succeed). The resulting amounts of each token to be tendered or received, after all trades are netted out, is called the network trade vector, which we have denoted Psi above.","category":"page"},{"location":"#Executing-solutions","page":"Home","title":"Executing solutions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The solution this package provides are a set of trades that, when netted out, maximizes the utility function U.  With a small amount of additional effort, it is possible to convert this unordered set of trades into a list of trades that can be included in a transaction. We will cover some approaches for how to convert a set of trades into a reasonable transaction in a future post.","category":"page"},{"location":"#Optimization-approach","page":"Home","title":"Optimization approach","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To solve the optimal routing problem presented here, this package uses a common technique in large scale optimization: we decompose the problem such that the optimal trade on each individual CFMM can be solved independently. It is easy to see that the only constraint coupling the CFMM trades together is","category":"page"},{"location":"","page":"Home","title":"Home","text":"Psi = sum_i=1^m A_i(Lambda_i - Delta_i)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Therefore, if we can eliminate this constraint, the subproblems can be solved in a fully parallelizable way. Intuitively, our approach is to relax this constraint to be a penalty in the objective, where there is some cost of violation. If we fix these costs at a given round, the CFMM subproblems can be solved independently. We then use these subproblem solutions to update the cost of violation and iterate this process. The algorithmic details are explained in the Solution method section.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: G. Angeris, T. Chitra, A. Evans, and S. Boyd. Optimal routing for constant function market makers.","category":"page"}]
}
